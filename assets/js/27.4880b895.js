(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{614:function(e,t,v){"use strict";v.r(t);var r=v(32),i=Object(r.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"promise的核心实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#promise的核心实现"}},[e._v("#")]),e._v(" Promise的核心实现")]),e._v(" "),v("ol",[v("li",[v("p",[e._v("Promise 就是一个类，在执行这个类的时候，需要传递一个执行器进去，执行器会立即执行")])]),e._v(" "),v("li",[v("p",[e._v("Promise中 有三种状态，分别为 成功 fulfilled 失败 rejected 等待 pending")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("pending  ==> fulfilled")])]),e._v(" "),v("li",[v("p",[e._v("pending   ==> rejected")])]),e._v(" "),v("li",[v("p",[e._v("一旦状态确定就不可更改")])])])]),e._v(" "),v("li",[v("p",[e._v("resolve 和 reject 函数就是用来更改状态的")]),e._v(" "),v("ul",[v("li",[e._v("resolve: fulfilled")]),e._v(" "),v("li",[e._v("rejected: rejected")])])]),e._v(" "),v("li",[v("p",[e._v("then 方法内部做的事情就是判断状态。状态成功，则调用成功的回调函数，状态时失败，则调用失败的回调函数。then 方法是被定义在原型对象中的")])]),e._v(" "),v("li",[v("p",[e._v("then成功回调和失败回调都有对应的值")])])]),e._v(" "),v("h2",{attrs:{id:"promise加入异步逻辑"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#promise加入异步逻辑"}},[e._v("#")]),e._v(" Promise加入异步逻辑")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("对于异步调用，因为不会立即执行，当前状态还是为 等待状态 pending")])]),e._v(" "),v("li",[v("p",[e._v("在 then 中要处理等待状态")])]),e._v(" "),v("li",[v("p",[e._v("所以需要对成功和失败的诡吊进行缓存")])])]),e._v(" "),v("h2",{attrs:{id:"promise-中-then方法多次调用添加多个处理函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#promise-中-then方法多次调用添加多个处理函数"}},[e._v("#")]),e._v(" Promise 中 then方法多次调用添加多个处理函数")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("多次调用时，需要缓存成功和失败调用相应的函数")])]),e._v(" "),v("li",[v("p",[e._v("缓存回调函数使用  队列结构，对数组 push 和 shift 运用")])])]),e._v(" "),v("h2",{attrs:{id:"promise中-then的链式调用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#promise中-then的链式调用"}},[e._v("#")]),e._v(" promise中 then的链式调用")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("then方法可以链式调用，需要返回一个 Promise 对象")])]),e._v(" "),v("li",[v("p",[e._v("判断上一个then成功调用的值是 普通值 还是 promise对象")]),e._v(" "),v("ul",[v("li",[e._v("普通值 直接调用 resolve")]),e._v(" "),v("li",[e._v("promise 对象先查看promise对象返回的结果，再根据结果决定调用resolve 还是reject")])])])]),e._v(" "),v("h2",{attrs:{id:"then方法链式调用识别-promise对象自己返回"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#then方法链式调用识别-promise对象自己返回"}},[e._v("#")]),e._v(" then方法链式调用识别 Promise对象自己返回")]),e._v(" "),v("ul",[v("li",[e._v("then 方法中如果返回的是 此时 then 方法返回的 Promise对象，则会报错")]),e._v(" "),v("li",[e._v("所以在 then 方法返回之前，需要判断返回的是否是当前 then方法的Promise对象，进行相应处理")]),e._v(" "),v("li",[e._v("在 当前then方法中没办法取得当前then返回的 Promise对象，则需要利用setTimeout 将相应代码转换成异步代码进行获取")])]),e._v(" "),v("h2",{attrs:{id:"捕获错误"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#捕获错误"}},[e._v("#")]),e._v(" 捕获错误")]),e._v(" "),v("ul",[v("li",[e._v("利用对"),v("strong",[e._v("执行器")]),e._v(" try-catch 操作捕获错误")]),e._v(" "),v("li",[e._v("在 then 的回调中发生的错误 也需要用 try-catch 捕获")])]),e._v(" "),v("h2",{attrs:{id:"then-方法传入的参数有空值时"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#then-方法传入的参数有空值时"}},[e._v("#")]),e._v(" then 方法传入的参数有空值时")]),e._v(" "),v("ul",[v("li",[e._v("遇到空值则调用 value => value 函数，将值向下传递即可")])]),e._v(" "),v("h2",{attrs:{id:"静态方法-all方法的实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#静态方法-all方法的实现"}},[e._v("#")]),e._v(" 静态方法 all方法的实现")]),e._v(" "),v("ul",[v("li",[e._v("all方法传入一个数组")]),e._v(" "),v("li",[e._v("判断数组中每个元素是 promise对象还是 普通值，声明结果数组\n"),v("ul",[v("li",[e._v("普通值则直接放入结果数组对应的位置")]),e._v(" "),v("li",[e._v("promise对象则调用then方法，成功回调则放入数组对应位置，失败回调则调用 reject 方法")])])]),e._v(" "),v("li",[e._v("为解决传入的数组元素是异步操作的promise，则需要声明一个长度变量index，在添入结果数组的操作中，判断index跟传入的数组长度相等时则返回 带有结果数组的 resolve 方法")])]),e._v(" "),v("h2",{attrs:{id:"静态方法-resolve-方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#静态方法-resolve-方法"}},[e._v("#")]),e._v(" 静态方法 resolve 方法")]),e._v(" "),v("ul",[v("li",[e._v("判断传入的时普通值还是 promise值\n"),v("ul",[v("li",[e._v("普通值则 返回含有该值的 resolve 方法的 promise 对象")]),e._v(" "),v("li",[e._v("promise 对象则直接返回")])])])]),e._v(" "),v("h2",{attrs:{id:"finally-方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#finally-方法"}},[e._v("#")]),e._v(" finally 方法")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("传入一个回调函数")])]),e._v(" "),v("li",[v("p",[e._v("不论当前 promise 对象的状态是成功还是失败，都需要调用该回调函数")])]),e._v(" "),v("li",[v("p",[e._v("要获得当前 promise的状态，需要调用 then 方法")])]),e._v(" "),v("li",[v("p",[e._v("避免异步调用的失效，返回调用 promise.resove 方法处理回调函数的返回值，并通过 then方法返回")])])]),e._v(" "),v("h2",{attrs:{id:"catch方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#catch方法"}},[e._v("#")]),e._v(" catch方法")]),e._v(" "),v("ul",[v("li",[e._v("返回 promise对象的then方法， 传入的方法作为失败回调即可")])])])}),[],!1,null,null,null);t.default=i.exports}}]);